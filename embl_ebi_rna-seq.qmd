---
title: "EMBL-EBI (RNA-seq)"
format: html
editor: visual
---

This data used here is from ([Yu et al., 2023](https://www.sciencedirect.com/science/article/pii/S2211124723014043)).

The study performed transcriptomic profiling of brain, lung and liver endothelial cells (ECs) from adult mice (2-4 months).

## RNA-seq

Load the libraries required.

```{r, results="hide", message=FALSE}
library(dplyr)
library(ggplot2)
library(ggthemes)
library(DESeq2)
library(tximport)
library(pheatmap)
library(gprofiler2)
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(ggrepel)
library(tibble)
library(purrr)
library(readr)
library(here)
library(apeglm)
library(biomaRt)
library(AnnotationHub)
library(memes)
library(TFBSTools)
library(JASPAR2024)
library(universalmotif)
```

### Load the RNA-seq data

Load the data frame that contains the mappings from transcript IDs to gene IDs and gene names.

```{r}
# Define file path to the tx2gene.tsv file
# here::here() constructs file paths relative to the root of the R project
tx2genefile = here::here('data/count_tables/tx2gene.tsv')
# Read the contents of the .tsv file, selecting only the first three columns of data
tx2gene = read.delim(tx2genefile, header=FALSE)[, 1:3]

knitr::kable(head(tx2gene))
```

The file, `tx2gene.tsv`, is a common format used in RNA-seq data analysis, especially when working with transcript quantification tools like Salmon, Kallisto, or other tools that assign read counts to transcripts. This file is used to map transcript IDs to gene IDs and gene names. There are three columns:

-   **Transcript ID**: contains transcript identifiers - each transcript ID corresponds to a specific mRNA transcript produced by a gene.

-   **Gene ID**: contains gene identifiers - these IDs represent the genes associated with the transcripts in column 1.

-   **Gene name**: contains gene names.

Create a list of `quant.sf` files in the `data/count_tables` directory.

`quant.sf` files are output files from tools like Salmon or Kallisto, which contain transcript quantification data.

```{r}
# Define the path to the count_tables directory
directory_path = here::here("data/count_tables")
# List all files in the count_tables directory (and subdirectories) named quant.sf
# recurvive=TRUE allows the function to search subdirectories
# full.names=TRUE returns the full file path, not just file names
files = list.files(path=directory_path, pattern="quant.sf", recursive=TRUE, full.names=TRUE)

files
```

Using `tximport()`, import and aggregate the transcript quantification data (from Salmon output files) into gene-level counts.

```{r}
# tximport() imports and aggregates transcript-level abundance estimates (like those produced by Salmon/Kallisto) into gene-level counts
# files is a list of file paths to the quantification files
# tx2gene=tx2gene provide the mapping between transcipts and genes
txi = tximport(files, type="salmon", tx2gene=tx2gene)
```

```{r}
names(txi) # txi is a list containing matricies of abundance, counts, lengths and countsFromAbundance
```

The `txi` object contains several components:

-   **Abundance**: contains transcript abundance estimates, typically expressed as TPM (Transcripts per Million) or FPKM/RPKM (Fragments/Kilobases per Million reads). TPM and FPKM/RPKM are normalised measures that account for both transcript level and sequencing depth, making them useful for comparing expression levels across samples.

-   **Counts**: represents the raw number of reads or fragments that have been assigned to each gene.

-   **Length**: contains the effective lengths of the transcripts (the effective length accounts for length of the transcript that is actually mappable, which might be shorter than the full transcript length). Effective lengths are used in the calculation of TPM or FPKM/RPKM.

-   **CountsFromAbundance**: indicates how the counts were derived from the abundance estimates.

    -   `"no"`: indicates that the counts are raw and have not been derived from the abundance values.

```{r}
txi$countsFromAbundance
```

Create a data frame that contains condition information for each sample.

```{r}
# Extract sample names from the file paths stored in the files variable
# sapply() applies a function to each element of a list and simplifies the result into a vector or matrix
# dirname(path) extracts the directory name from the full file path:
    # e.g. "/Users/laurahuggon/RProjects/embl_ebi_rna-seq/data/count_tables/BR1-EC_bRNA"
# basename(dirname(path)) then extracts the base name of this directory:
    # e.g. "BR1-EC_bRNA"
samples = sapply(files, function(path) {basename(dirname(path))})
# Extract the condition from the sample names
# Extract the base directory name (the sample name) and uses the sub() function to replace any characters (.*) after "1-", "2-", or "3-" with an empty string
condition = sapply(files, function(path) {
  folder_name = basename(dirname(path))
  sub("([123]-.*)", "", folder_name)
})

# Create a data frame to store the condition information
# The resulting data frame has as many rows as there are files, each corresponding to a sample
data = data.frame(condition=condition)
# Set the row names to the sample names
rownames(data) = samples
  
knitr::kable(data)
```

### Differential Expression Analysis (DEA)

Use the `DESeq2` library to perform differential gene expression analysis and normalise counts for making plots such as PCA, heatmaps, etc.

Create a DESeqDataSet object using the `txi` data. This is the primary data structure used by the DESeq2 package for DEA.

The `dds` object is created using `DESeqDataSetFromTximport()` function, which takes the imported transcipt data (`txi`), sample metadata (`data`), and a design formula (`condition`) as inputs.

```{r}
# colData is a data frame that contains metadata about the samples
# design=~condition specifies that the DEA will be based on the condition variable, which represents different experimental groups
# The tilde (~) indicates that the analysis will model how the condition affects gene expression (i.e. the result will be a comparison of expression levels across the different conditions)
dds = DESeqDataSetFromTximport(txi, colData=data, design=~condition)
```

```{r}
dds # dds contains 45,706 genes and 9 samples
```

`dds` contains:

-   **Counts**: the raw read counts for each gene in each sample

    ```{r}
    knitr::kable(head(counts(dds)))
    ```

-   **Sample metadata**: information about each sample, such as experimental conditions.

    ```{r}
    knitr::kable(colData(dds))
    ```

-   **Design formula**: the model formula used to explain how gene expression varies with conditions.

    ```{r}
    design(dds)
    ```

-   **Gene/feature metadata**: additional information about each gene/feature.

    ```{r}
    rowData(dds) # Gene identifiers are row names (not a column)
    ```

Use the `DESeq()` function to perform a series of steps to analyse RNA-seq count data for differential expression between experimental conditions:

-   **Estimation of size factors**: normalises the count data to account for differences in sequencing depth or library size across samples.

-   **Estimation of dispersions**: estimates the dispersion parameter for each gene, which reflects the variability of counts across replicates.

-   **Fitting the model**: fits a generalised linear model (GLM) for each gene, based on the design formula specified (`~condition` in this case).

-   **Wald Test or Likelihood Ratio Test**: performs statistical tests (typically a Wald test) to determine if there is a significant difference in gene expression between conditions.

```{r}
# Run the DEA piepline on dds
dds = DESeq(dds)
```

After running this function, the `dds` object contains additional information such as:

-   **Normalised counts**: the count data normalised by the estimated size factors.

-   **Dispersions**: estimates of dispersion for each gene.

-   **Fitted model parameters**: coefficients from the GLM.

-   **Test results**: p-values and log2 fold changes indicating differential expression.

Perform a variance stabilising transformation (VST) on the normalised counts.

VST aims to stabilise variance across the range of mean values. This is important as RNA-seq data typically exhibit a mean-variance relationship, which is where expression level of the gene affects the variability of that gene.

```{r}
# The resultant vsd object contains variance-stabilised normalised counts (this is a log2-like scale but with variance stabilised across the range of counts)
vsd = vst(dds, blind=TRUE) # Do not take into account the experimental design

# Convert to a matrix to view
vsd_matrix = assay(vsd)
knitr::kable(head(vsd_matrix))
```

Apply log2(n + 1) transformation to the normalised counts using `normTransform()`.

log2(n + 1) transformation helps to make the data more interpretable, especially when dealing with count data that has a wide range of expression levels. n + 1 handles zero values before performing the log transformation.

```{r}
# The resultant ntd object contains log2-transformed normalised counts
ntd = normTransform(dds)

# Convert to a matrix to view
ntd_matrix = assay(ntd)
knitr::kable(head(ntd_matrix))
```

Perform PCA on the variance-stabilised data (`vsd`) and generate a PCA plot using `PlotPCA()`.

PCA is a dimensionality reduction technique that helps to visualise the variation in gene expression data across samples, often revealing patterns such as clustering of samples by condition or batch effects.

The variance-stabilised data is used here as PCA aims to capture the structure in the data by identifying principal components that explain the maximum variance. If variance is not stabilisated, the genes with high variability (which is determined by expression levels) might disproportionately influence the principal components.

```{r}
# intgroup="condition" specifies the grouping variable(s) of interest that will be used to colour the samples in the PCA plot, making it easier to observe how samples group according to this variable
# returnData=TRUE returns the data used to generate the PCA plot instead of the plot itself
pcaData = plotPCA(vsd, intgroup="condition", returnData=TRUE)
```

`pcaData` contains:

-   **PC1**: the coordinates of each sample along the first principal component.

-   **PC2**: the coordinates of each sample along the second principal component.

-   **group**: the grouping variable associated with each sample.

```{r}
knitr::kable(pcaData)
```

List all the attributes associated with `pcaData`. An attribute is a piece of metadata or a property that provides additional information about an object.

```{r}
attributes(pcaData)
```

Calculate the percentage of variance explained by the first two principal components (PC1 and PC2).

This indicates how much of the total variability in the data is captured by these two components.

```{r}
# Retrieve the "percentVar" attribute for the pcaData object, and convert the fraction of variance explained to a percentage
percentVar = round(100 * attr(pcaData, "percentVar"))

percentVar
```

Visualise the PCA plot.

This plot helps to visualise how samples group based on their experimental conditions in the reduced PC space and understand the variance captured by the first two PCs. This can reveal if there are distinct clusters or overlaps between groups.

You can also identify if any samples are outliers.

```{r}
ggplot(pcaData, aes(PC1, PC2, color=condition)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed() + # Ensures that that scaling of the x- and y-axis are fixed
  theme_few()
```

PC1 and PC2 account for 96% of the total variance in the dataset - these two components capture a substantial portion of the data's variability. This indicates that the reduced 2D representation is capturing most of the essential information, making it easier to visualise meaningful patterns/clusters/relationships.

### Quality control

These samples were collected directly after FACs sorting so these cells might be stressed.

Look at highly expressed genes in each condition and see if these genes are enriched in stress-related GO terms.

Select the top 300 genes based on average normalised counts (which contains the library size normalised counts) to identify the the genes with the highest expression levels across all the samples.

```{r}
# counts(dds, normalized=TRUE) retrieves the normalised counts
# Calculate the mean normalised count for each gene across all samples
# Order the genes based on their mean normalised counts in descending order (this function returns the indices of the genes)
# Select the top 300 genes with the highest average expression
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:300]

head(select) # Each integer represents the index of a gene in the original dataset
```

Once these genes have been selected, extract the counts data for the top 300 genes from the `ntd` object (which contains the log2 normalised counts).

GO enrichment analysis focuses on expression levels and the log2 transformation helps in compressing the range of expression values and handling zero values. This transformation also mitigates issues like skewness which impacts the assumptions of statistical methods that assume normally distributed data.

```{r}
# Only include the counts of the selected genes
top300 <- as.data.frame(assay(ntd)[select,])

knitr::kable(head(top300))
```

Perform GO enrichment analysis to identify GO terms that are overrepresented among the top 300 genes.

```{r}
# Perform GO enrichment analysis using the gene identifiers provided in the row name
go_enrich = gost(rownames(top300), organism = "mmusculus",ordered_query = TRUE) # Specify the organism is a mouse and that the gene list is provided in a specific order
# Visualise result of GO enrichment analysis
gostplot(go_enrich, interactive = TRUE)
```

Modify the `go_enrich` data frame to only include relevant columns:

-   `query`: query name/identifier. A query is the set of genes you are interested in investigating.

-   `source`: source of the Go term (e.g. GO, KEGG).

-   `term_id`: ID of the GO term.

-   `term_name`: name/description of the GO term.

-   `p_value`: p-value for the enrichment of the GO term.

-   `query_size`: number of genes in the query list.

-   `intersection_size`: number of genes in the query list that overlap with the GO term.

-   `term_size`: total number of genes associated with the GO term.

-   `effective_domain_size`: the size of the background gene set used for the enrichment analysis. This adjusts for the fact that some GO terms are more likely to be enriched simply because they are associated with a larger number of genes in the genome.

```{r}
gp_mod = go_enrich$result[,c("query", "source", "term_id",
                                "term_name", "p_value", "query_size", 
                                "intersection_size", "term_size", 
                                "effective_domain_size")]

knitr::kable(head(gp_mod))
```

Calculate gene and background ratios to assess the proportion of genes involved in a term relative to the query and background.

-   **GeneRatio**: the ratio of the number of query genes that intersect with the GO term to the total number of genes in the query list. It helps to understand what proportion of the entire query list is associated with a specific GO term.

-   **BgRatio**: the ratio of the number of genes associated with the GO term to the effective domain size. This helps to understand the proportion of background genes associated with the GO term, offering insight into its general relevance.

```{r}
gp_mod$GeneRatio = paste0(gp_mod$intersection_size,  "/", gp_mod$query_size)
gp_mod$BgRatio = paste0(gp_mod$term_size, "/", gp_mod$effective_domain_size)
```

Rename columns.

```{r}
names(gp_mod) = c("Cluster", "Category", "ID", "Description", "p.adjust", 
                    "query_size", "Count", "term_size", "effective_domain_size", 
                    "GeneRatio", "BgRatio")
```

Set the row names of the `gp_mod` data frame to the GO term IDs.

```{r}
row.names(gp_mod) = gp_mod$ID

knitr::kable(head(gp_mod))
```

The `result` data frame, which contains the enrichment analysis, is ordered first by query name, data source (such as GO:BP, GO:CC, etc.), and then by the adjusted p-value.

Create an `enrichResult` object from the modified data frame. This class is used by the `enrichplot` package to generate plots.

```{r}
# Define as enrichResult object
gp_mod_enrich  = new("enrichResult", result = gp_mod)
# Generate a dotplot
enrichplot::dotplot(gp_mod_enrich)
```

The GO terms largely relate to normal developmental processes and anatomical structure formation.

Anatomical structure morphogenesis, vasculature development, and blood vessel development are related to normal EC function.

Changes in mitochondrial components can indicate stress, as mitochondrial dysfunction often correlate with cellular stress responses.

### Differentially expressed genes between conditions

Look for genes enriched in brain ECs compared to lung or liver.

```{r}
# Extract the results of the DEA from dds
res = results(dds)

knitr::kable(head(res))
```

The default output columns are:

-   **log2FoldChange**: log2 fold change of expression for each gene between conditions.

    -   Fold change values are represented in log2 scale to symmetrically represent both upregulation and downregulation of gene expression. For example, a fold change of 2 (upregulation) and a fold change of -0.5 (downregulation) are symetrically represented as +1 and -1 on a log2 scale.

    -   As raw fold change values can vary widely, using a log2 scale also compresses this range.

-   **lfcSE**: standard error of the log2 fold change.

-   **stat**: test statistics (Wald test or likelihood ratio test) for each gene.

-   **pvalue**: p-value for test of differential expression.

-   **padj**: the adjusted p-value (using the Benjamini-Hochberg procedure) to control for false discovery rate.

List the names of the coefficients (i.e. terms in the design formula) that are available in `dds` for which you can extract results. This is useful for understanding which comparisons are available in the model.

```{r}
resultsNames(dds)
```

We want genes that are overexpressed in the brain compared to both lung and liver. Here, this will be represented by genes that have a negative `log2FoldChange` in the comparisons named above.

What kind of threshold should we use for `log2FoldChange` and `padj`? Use a volcano plot to help decide.

```{r}
# Set thresholds
foldchange=2 # Threshold for log2 fold change
pval=0.001 # Threshold for adjusted p-value
```

A volcano plot is a common way to visualise DEA data. It shows the relationship between the magnitude of change (log2 fold change) and statistical significance (adjusted p-value).

-   The adjusted p-value is plotted on the volcano plot as `-log10(padj)`. The raw p-values are often very small for significant results, and visualising them on a log scale compresses a wide range of p-values into a more manageable range where highly significant results are visually distinct.

-   Lower p-values (high significance) are also emphasised as larger values on the y-axis.

```{r}
# Create function that generates a volcano plot that takes a coefficient of dds as an argument
PlotVolcano <-function(comparison){
  # Shrink the log2 fold changes using the apeglm method to stabilise the estimates,       especially for genes with low counts or low variance
  # The output, de, is a DESeq2 object that contains shruken log2 fold changes
  de = lfcShrink(dds, coef=comparison, type="apeglm")
  # Convert de into a data frame, resul
  resul = as.data.frame(de)
  # Extract gene IDs and assign them to resul as a new column
  resul$geneID <- rownames(resul)
  # Merge resul with additional gene annotations (gene names) stored in tx2gene
  # Column "geneID" in res corresponds to column "V2" in tx2gene
  # Keep all rows in resul
  # Only matching rows in tx2gene are kept
  de <- merge(resul, tx2gene, by.x = "geneID", by.y = "V2", all.x = TRUE, all.y = FALSE)
  
  # Filtering and selection
  de = de %>% 
    dplyr::filter(!is.na(log2FoldChange)) %>% # Remove any rows with NA values in the log2FoldChange column
    dplyr::select(-V1) %>% # Remove column "V1" (transcript ID)
    unique() # Remove duplicate rows
  
  # Count how many genes are in each category (unchanged, upregulated, downregulated)
  n_unchanged <- de %>% 
    # Filter for genes where log2FoldChange is between -foldchange and +foldchange
    dplyr::filter(log2FoldChange < foldchange & log2FoldChange > -(foldchange)) %>% 
    # Count how many genes unchanged
    nrow()
  n_up <- de %>%
    # Filter for genes where log2FoldChange is greater than foldchange and significant (based on pval)
    dplyr::filter(log2FoldChange >= foldchange & padj < pval) %>%
    # Count how many genes upregulated
    nrow()
  n_down <- de %>% 
    # Filter for genes where log2FoldChange is less than -foldchange and significant (based on pval)
    dplyr::filter(log2FoldChange <= -(foldchange) & padj < pval) %>% 
    # Count how many genes downregulated
    nrow()
  
  # Assign DE labels to genes
  # Create "diffexpressed" column and label all genes as "Unchanged" with total count of unchanged genes
  de$diffexpressed <- paste0("Unchanged (",n_unchanged,")")
  # For genes where log2FoldChange is greater than foldchange and significant, the label is updated to "Up" with a total count of upregulated genes
  de$diffexpressed[de$log2FoldChange >= foldchange & de$padj < pval] <- paste0("Up (",n_up,")")
  # For genes where log2FoldChange is less than -foldchange and significant, the label is updated to "Down" with a total count of downregulated genes
  de$diffexpressed[de$log2FoldChange <= -(foldchange) & de$padj < pval] <- paste0("Down (",n_down,")")
  
  # Set colours for plot - the order of colours will correspond to the order of levels in the factor variable de$diffexpressed
  if (n_up == 0 & n_down == 0){ # If there are no up or downregulated genes
      cvec = c("#84A1AB") # Use grey-blue for all genes
  } else if (n_up == 0){ # If there are only downregulated genes
      cvec = c("#B02302", "#84A1AB") # Use red for down genes and grey-blue for unchanged genes
  } else if (n_down == 0){ # If there are only upregulated genes
      cvec = c("#84A1AB", "#61B002") # Use grey-blue for unchanged genes and green for up genes
  } else { # If there are downregulated and upregulated genes
      cvec = c("#B02302", "#84A1AB", "#61B002") # Use red for down genes, and grey-blue for unchanged genes, and green for up genes
  }
  
  # Add gene names to genes that are differentially expressed
  # Create "delabel" column and initialise with NA values for all rows (by default, no genes are labelled on the plot)
  de$delabel <- NA
  # Select "delabel" entries where "diffexpressed" does not contain "Unchanged"
  # Select and assign gene names (from "V3") where "diffexpressed" does not contain "Unchanged"
  de$delabel[!grepl("Unchanged", de$diffexpressed)] <- de$V3[!grepl("Unchanged", de$diffexpressed)]
  # Sort the data frame by adjusted p-values
  de=de[order(de$padj),]
  
  
  # Generate the volcano plot
  # The x-axis is mapped to the log2 fold change values (i.e. magnitude of change)
  # The y-axis is mapped to the -log10  of the padj values (i.e. significance)
  ggplot(data=de, aes(x=log2FoldChange, y=-log10(padj))) +
          # Add vertical dashed lines at the foldchange thresholds
          geom_vline(xintercept=c(-(foldchange), foldchange), col="light grey", linetype="dashed") +
          # Add horizontal dashed line at the pval threshold
          geom_hline(yintercept=-log10(pval), col="light grey", linetype="dashed") +
          # Add points to the plot, coloured by "diffexpressed" column
          geom_point(aes(color=diffexpressed), alpha=0.5) +
          # Add text lables (avoiding overlap) to the top 50 most signficant DE genes
          # Set x- and y-coordinates for labels using "log2FoldChange" and "padj" columns
          geom_text_repel(data=de[1:50,],aes(x = log2FoldChange, y = -log10(padj),label=delabel),max.overlaps=50,size=3) +
          # Use colours specified earlier
          scale_color_manual(values=cvec) +
          # Set appearance
          theme_few() +theme(aspect.ratio=1) +
          labs(title = comparison)
}
```

```{r}
PlotVolcano("condition_LG_vs_BR")
```

```{r}
PlotVolcano("condition_LV_vs_BR")
```

Look at genes overexpressed in the brain compared to both lung and liver.

Identify genes that are significantly downregulated in lung samples compared to brain samples.

```{r, message=FALSE}
# Shrink the log2 fold changes using the apeglm method to stabilise the estimates,       especially for genes with low counts
brainlung = lfcShrink(dds, coef="condition_LG_vs_BR", type="apeglm") %>%
  # Covert the DESeq2 object to a data frame
  as.data.frame() %>%
  # Filter genes for signficance and log2 fold change
  filter(padj<0.001 & log2FoldChange <= -2) %>%
  # Extract row names of filtered data frame
  rownames()

head(brainlung) # The output is a vector of gene IDs
```

Shrinking log2 fold changes is used to reduce noise in low-count genes.

-   Genes with low counts often show exaggerated or highly variable log2 fold changes.

-   Shrinking the log2fold changes helps reduce this noise by pulling extreme values towards more conservative or "shrunk" estimates, reflecting more accurate differences in gene expression.

Identify genes that are significantly downregulated in liver samples compared to brain samples.

```{r, message=FALSE}
# Shrink the log2 fold changes using the apeglm method to stabilise the estimates,       especially for genes with low counts
brainliver = lfcShrink(dds, coef="condition_LV_vs_BR", type="apeglm") %>%
  # Covert the DESeq2 object to a data frame
  as.data.frame() %>%
  # Filter genes for signficance and log2 fold change
  filter(padj<0.001 & log2FoldChange <= -2) %>%
  # Extract row names of filtered data frame
  rownames()

head(brainliver) # The output is a vector of gene IDs
```

```{r}
length(brainlung) # 388 genes are downregulated in LG compared to BR
```

```{r}
length(brainliver) # 743 genes are downregulated in LV compared to BR
```

Get the genes that are downregulated in both the lung and liver compared to the brain.

```{r}
# interest() returns the gene IDs that are common to both vectors
brain_enriched = intersect(brainlung,brainliver) %>% 
# Remove duplicates
  unique()

length(brain_enriched) # 229 genes are downregulated in LG and LV compared to the brain
```

As a control set for later, identify liver enriched genes.

```{r, message=FALSE}
liver_enriched = lfcShrink(dds, coef="condition_LV_vs_BR", type="apeglm") %>%
  as.data.frame() %>%
  filter(padj<0.001 & log2FoldChange >= 2) %>%
  rownames() %>% unique
```

```{r}
length(liver_enriched) # 788 genes are upregulated in LV compared to brain
```

Perform GO analysis to see what kind of gene networks they belong to.

```{r}
# Perform GO enrichment analysis using the brain enriched genes
go_enrich = gost(brain_enriched, organism = "mmusculus")  # Specify the organism is a mouse
# Visualise result of GO enrichment analysis
gostplot(go_enrich, interactive = TRUE)
```

Modify the `go_enrich` data frame as done earlier.

```{r}
# Only include relevant columns
gp_mod = go_enrich$result[,c("query", "source", "term_id",
                                "term_name", "p_value", "query_size", 
                                "intersection_size", "term_size", 
                                "effective_domain_size")]

# Calculate GeneRatio and BgRatio
gp_mod$GeneRatio = paste0(gp_mod$intersection_size,  "/", gp_mod$query_size)
gp_mod$BgRatio = paste0(gp_mod$term_size, "/", gp_mod$effective_domain_size)

# Rename columns
names(gp_mod) = c("Cluster", "Category", "ID", "Description", "p.adjust", 
                    "query_size", "Count", "term_size", "effective_domain_size", 
                    "GeneRatio", "BgRatio")

# Set row names to the GO term IDs
row.names(gp_mod) = gp_mod$ID

# Define as enrichResult object
gp_mod_enrich  = new("enrichResult", result = gp_mod)

knitr::kable(head(gp_mod))
```

Generate a bar plot to visualise the result of the GO enrichment analysis, showing the top 25 enriched GO terms.

```{r, fig.width=10, fig.height=10}
barplot(gp_mod_enrich, showCategory = 25, font.size = 12) + 
  ggplot2::facet_grid(~Cluster)
```

This plot provides a visual summary of the 25 most enriched GO terms.
