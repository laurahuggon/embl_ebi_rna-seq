---
title: "EMBL-EBI (RNA-seq)"
format: html
editor: visual
---

This data used here is from ([Yu et al., 2023](https://www.sciencedirect.com/science/article/pii/S2211124723014043)).

The study performed transcriptomic profiling of brain, lung and liver endothelial cells (ECs) from adult mice (2-4 months).

## Load libraries

```{r, results="hide", message=FALSE}
library(dplyr)
library(ggplot2)
library(ggthemes)
library(DESeq2)
library(tximport)
library(pheatmap)
library(gprofiler2)
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(ggrepel)
library(tibble)
library(purrr)
library(readr)
library(here)
library(apeglm)
library(biomaRt)
library(AnnotationHub)
library(memes)
library(TFBSTools)
library(JASPAR2024)
library(universalmotif)
library(vsn)
library(ComplexHeatmap)
library(reshape2)
library(grid)
```

## Load RNA-seq data

Load the data frame that contains the mappings from transcript IDs to gene IDs and gene names.

```{r}
# Define file path to the tx2gene.tsv file
# here::here() constructs file paths relative to the root of the R project
tx2genefile = here::here('data/count_tables/tx2gene.tsv')
# Read the contents of the .tsv file, selecting only the first three columns of data
tx2gene = read.delim(tx2genefile, header=FALSE)[, 1:3]

knitr::kable(head(tx2gene))
```

The file, `tx2gene.tsv`, is a common format used in RNA-seq data analysis, especially when working with transcript quantification tools like Salmon, Kallisto, or other tools that assign read counts to transcripts. This file is used to map transcript IDs to gene IDs and gene names. There are three columns:

-   **Transcript ID**: contains transcript identifiers - each transcript ID corresponds to a specific mRNA transcript produced by a gene.

-   **Gene ID**: contains gene identifiers - these IDs represent the genes associated with the transcripts in column 1.

-   **Gene name**: contains gene names.

Create a list of `quant.sf` files in the `data/count_tables` directory.

`quant.sf` files are output files from tools like Salmon or Kallisto, which contain transcript quantification data.

```{r}
# Define the path to the count_tables directory
directory_path = here::here("data/count_tables")
# List all files in the count_tables directory (and subdirectories) named quant.sf
# recurvive=TRUE allows the function to search subdirectories
# full.names=TRUE returns the full file path, not just file names
files = list.files(path=directory_path, pattern="quant.sf", recursive=TRUE, full.names=TRUE)

files
```

Using `tximport()`, import and aggregate the transcript quantification data (from Salmon output files) into gene-level counts.

```{r}
# tximport() imports and aggregates transcript-level abundance estimates (like those produced by Salmon/Kallisto) into gene-level counts
# files is a list of file paths to the quantification files
# tx2gene=tx2gene provide the mapping between transcipts and genes
txi = tximport(files, type="salmon", tx2gene=tx2gene)
```

```{r}
names(txi) # txi is a list containing matricies of abundance, counts, lengths and countsFromAbundance
```

The `txi` object contains several components:

-   **Abundance**: contains transcript abundance estimates, typically expressed as TPM (Transcripts per Million) or FPKM/RPKM (Fragments/Kilobases per Million reads). TPM and FPKM/RPKM are normalised measures that account for both transcript length and library size, making them useful for comparing expression levels across samples.

-   **Counts**: represents the raw number of reads or fragments that have been assigned to each gene.

-   **Length**: contains the effective lengths of the transcripts (the effective length accounts for length of the transcript that is actually mappable, which might be shorter than the full transcript length). Effective lengths are used in the calculation of TPM or FPKM/RPKM.

-   **CountsFromAbundance**: indicates how the counts were derived from the abundance estimates.

    -   `"no"`: indicates that the counts are raw and have not been derived from the abundance values.

```{r}
txi$countsFromAbundance
```

Create a data frame that contains condition information for each sample.

```{r}
# Extract sample names from the file paths stored in the files variable
# sapply() applies a function to each element of a list and simplifies the result into a vector or matrix
# dirname(path) extracts the directory name from the full file path:
    # e.g. "/Users/laurahuggon/RProjects/embl_ebi_rna-seq/data/count_tables/BR1-EC_bRNA"
# basename(dirname(path)) then extracts the base name of this directory:
    # e.g. "BR1-EC_bRNA"
samples = sapply(files, function(path) {basename(dirname(path))})
# Extract the condition from the sample names
# Extract the base directory name (the sample name) and uses the sub() function to replace any characters (.*) after "1-", "2-", or "3-" with an empty string
condition = sapply(files, function(path) {
  folder_name = basename(dirname(path))
  sub("([123]-.*)", "", folder_name)
})

# Create a data frame to store the condition information
# The resulting data frame has as many rows as there are files, each corresponding to a sample
data = data.frame(condition=condition)
# Set the row names to the sample names
rownames(data) = samples
  
knitr::kable(data)
```

## Data exploration

### Remove unexpressed genes

Extract the raw counts matrix from `txi`.

```{r}
counts_matrix = txi$counts

# Assign sample names as column names
colnames(counts_matrix) = rownames(data)

knitr::kable(head(counts_matrix))
```

Genes with low expression levels across all samples should be filtered out (e.g. not all mouse genes in the genome will be expressed in these samples). This removes noise from the data, making results more reliable and improves statistical power.

Determine the optimal filtering criteria.

Use Counts Per Million (CPM) to normalise for raw count variability (by expressing counts relative to the total number of reads in the sample). This is calculated by:

$$\text{CPM} = \left(\frac{\text{Raw Count}}{\text{Total Reads for Sample}}\right) \times 1{,}000{,}000$$

```{r}
# Define the function to plot the number of genes retained based on CPM thresholds
# The min_samples parameter is used to define the minimum number of samples with CPM above min_cpm to keep a gene to be considered retained
plot_genes_retained_by_cpm <- function(data, min_samples=2) {
  
  # Convert raw counts to CPM (Counts Per Million)
  # 2 indicates that the operation should be performed across columns
  # colSums(data) calculates the sums of counts for each sample (i.e. sum for each column)
  # Therefore, for each column in the data matrix, divide each entry by the total sum of that column
  cpm <- sweep(data, 2, colSums(data), FUN = "/") * 1e6
  
  # Define a range of CPM thresholds to test (from 0 to 5 with increments of 0.1)
  thresholds <- seq(0, 5, by = 0.1)
  
  # Initialise a vector to store the number of genes retained for each threshold
  # Creates an empty numeric vector with the same length as thresholds
  genes_retained <- numeric(length(thresholds))
  
  # Loop through each threshold value and calculate the number of genes retained
  for (i in seq_along(thresholds)) { # Generates a sequence of indices from 1 to the length of thresholds
    min_cpm <- thresholds[i] # Set min_cpm to the current threshold value being processed
    
    # cpm > min_cpm creates a logical matrix where each element is TRUE if the CPM for that gene in that sample is greater than the current threshold (min_cpm)
    # rowSums(cpm > min_cpm) calculates the number of samples for which each gene has a CPM greater than min_cpm - this creates a vector where each element represents the number of samples meeting the threshold for each gene
    # Then create logical vector (mask) where each element is TRUE if the rowSums() element is greater than or equal to the min_samples requirement
    mask <- rowSums(cpm > min_cpm) >= min_samples
    
    # Count the number of TRUE values in the mask vector, which corresponds to the number of genes retained for the current threshold
    # This count is stored at the index corresponding to the current threshold
    genes_retained[i] <- sum(mask)
  }
  
  # Create data frame used for plotting
  plot_data <- data.frame(thresholds = thresholds, genes_retained = genes_retained)
  
  # Plot the number of genes retained as a function of CPM threshold using ggplot2
  ggplot(plot_data, aes(x = thresholds, y = genes_retained)) +
    geom_line(color = "chartreuse4") +  # Line plot for the gene counts
    geom_point(color = "chartreuse4") +  # Add points to the plot
    geom_vline(xintercept = 1, color = "red", linetype = "dashed", label = "CPM = 1") +  # Vertical line at CPM = 1
    labs(x = "Threshold (CPM)", y = "Number of Genes Retained") +
    theme_minimal()
}


plot_genes_retained_by_cpm(counts_matrix)
```

This plot displays the number of genes retained as a function of different CPM thresholds. For many bulk RNA-seq datasets, a CPM threshold of 1 is a common filtering point.

Count the number of rows (genes) in `txi` before filtering.

```{r}
nrow(txi$counts) # 45,706 genes
```

Here, we will filter genes with an expression threshold of \>0.75 CPM in at least two samples.

```{r}
filter_genes_by_cpm <- function(data, min_cpm = 0.75, min_samples = 2) {
    # min_cpm: min counts per million (CPM) threshold for filtering genes.
    # min_sample: min number of samples with CPM above min_cpm to keep a gene.
  
  # Convert raw counts to CPM (Counts Per Million)
  cpm <- sweep(data, 2, colSums(data), FUN = "/") * 1e6  # Divide by total counts and multiply by 1M to get CPM
  
  # Filter genes based on CPM threshold
  # Create a logical mask where CPM > min_cpm in at least min_samples samples
  mask <- rowSums(cpm > min_cpm) >= min_samples
  
  # Apply the filter to retain only genes that pass the mask
  # Only keep the rows (genes) where the mask is TRUE
  filtered_data <- data[mask, ]
  
  return(filtered_data)
}

# Apply the filtering to the counts matrix in txi
# filtered_genes contains only the genes that pass the filter
filtered_genes <- filter_genes_by_cpm(txi$counts)

# Update txi to include only the filtered genes
# The matrices are filtered to only keep the rows (genes) that are present in filtered_genes
txi$abundance <- txi$abundance[rownames(filtered_genes), ]
txi$counts <- txi$counts[rownames(filtered_genes), ]
txi$length <- txi$length[rownames(filtered_genes), ]
```

Count the number of rows (genes) after filtering.

```{r}
nrow(txi$counts) # 16,230 genes
```

### Library size differences

Differences in the total number of reads (that have been assigned to genes) between samples typically occur for technical reasons. In practice, it means that we can not simply compare a gene’s raw read count directly between samples and conclude that a sample with a higher read count also expresses the gene more strongly - the higher count may be caused by an overall higher number of reads in that sample.

Update the counts matrix from `txi`.

```{r}
counts_matrix = txi$counts

# Assign sample names as column names
colnames(counts_matrix) = rownames(data)

knitr::kable(head(counts_matrix))
```

Compare the library sizes of all samples.

```{r}
# Calculate library sizes (total counts per sample) by summing the counts for each column
libSize <- colSums(counts_matrix)

# Create a data frame for plotting
plot_data = data.frame(
  sample = names(libSize),
  libSize = libSize
)

# Merge with group information
plot_data = cbind(plot_data, data)

# Remove row names
rownames(plot_data) = NULL

knitr::kable(plot_data)
```

```{r}
# Plot library sizes
ggplot(plot_data, aes(x = sample, y = libSize / 1e6, fill = condition)) + 
  geom_bar(stat = "identity") + 
  labs(x = "", y = "Total count in millions", title="Sequencing depth per sample") + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        plot.title = element_text(face = "bold"))
```

This plot helps visualise the overall sequencing depth/library size across the samples. Ideally, the sequencing depth should be consistent across samples.

### Variability and distribution of gene expression counts

Use a box and whisker plot to assess the variability and distribution of gene expression counts across the samples.

```{r}
# Log transform the counts
log_counts_matrix = log2(counts_matrix + 1)

# Reshape the counts matrix (convert to long format)
counts_long = melt(log_counts_matrix)

# Rename columns
colnames(counts_long) = c("Gene", "Sample", "Count")

# Create condition data frame
# Extract sample names (which were previously set as row names)
condition = data.frame(Sample=rownames(data), condition=data$condition)

# Merge with condition information
counts_long <- merge(counts_long, condition, by="Sample")

knitr::kable(head(counts_long))
```

```{r}
# Plot box and whisker
ggplot(counts_long, aes(x = Sample, y = Count, fill = condition)) +
  geom_boxplot(outlier.shape = NA) +  # Avoid showing outliers
  labs(x = "", y = "log2(counts + 1)", title="Gene expression counts per sample") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        plot.title = element_text(face = "bold"))
```

This plot shows the log2 transformed gene expression counts per sample. The boxes represent the interquartile range (middle 50% of the data) and the whiskers represent variability outside the upper and lower quartiles.

Ideally, the boxes and whiskers should be of similar sizes across the samples, indicating a consistent data distribution. By comparing the boxes across samples, you can see if certain samples have higher or lower expression levels overall. If the median varies significantly between samples, this suggests some samples have more overall expression than others. If the spread/height of the boxes (IQR) differs between samples, this suggests these samples have greater variability in gene expression.

## Differential Expression Analysis (DEA)

Use the `DESeq2` library to perform differential gene expression analysis and normalise counts for making plots such as PCA, heatmaps, etc.

Create a DESeqDataSet object using the `txi` data. This is the primary data structure used by the DESeq2 package for DEA.

The `dds` object is created using `DESeqDataSetFromTximport()` function, which takes the imported transcipt data (`txi`), sample metadata (`data`), and a design formula (`condition`) as inputs.

```{r}
# colData is a data frame that contains metadata about the samples
# design=~condition specifies that the DEA will be based on the condition variable, which represents different experimental groups
# The tilde (~) indicates that the analysis will model how the condition affects gene expression (i.e. the result will be a comparison of expression levels across the different conditions)
dds = DESeqDataSetFromTximport(txi, colData=data, design=~condition)
```

```{r}
dds # dds contains 16,230 genes and 9 samples
```

`dds` contains:

-   **Counts**: the raw read counts for each gene in each sample

    ```{r}
    knitr::kable(head(counts(dds)))
    ```

-   **Sample metadata**: information about each sample, such as experimental conditions.

    ```{r}
    knitr::kable(colData(dds))
    ```

-   **Design formula**: the model formula used to explain how gene expression varies with conditions.

    ```{r}
    design(dds)
    ```

-   **Gene/feature metadata**: additional information about each gene/feature.

    ```{r}
    rowData(dds) # Gene identifiers are row names (not a column)
    ```

Use the `DESeq()` function to perform a series of steps to analyse RNA-seq count data for differential expression between experimental conditions:

-   **Estimation of size factors**: normalises the count data to account for differences in sequencing depth or library size across samples.

-   **Estimation of dispersions**: estimates the dispersion parameter for each gene, which reflects the variability of counts across replicates.

-   **Fitting the model**: fits a generalised linear model (GLM) for each gene, based on the design formula specified (`~condition` in this case).

-   **Wald Test or Likelihood Ratio Test**: performs statistical tests (typically a Wald test) to determine if there is a significant difference in gene expression between conditions.

```{r}
# Run the DEA piepline on dds
dds = DESeq(dds)
```

After running this function, the `dds` object contains additional information such as:

-   **Normalised counts**: the count data normalised by the estimated size factors.

-   **Dispersions**: estimates of dispersion for each gene.

-   **Fitted model parameters**: coefficients from the GLM.

-   **Test results**: p-values and log2 fold changes indicating differential expression.

## Transformation

Most downstream analyses work best in situations where the variance of the input data (here, each gene) is relatively independent of the average value. For read count data such as RNA-seq, this is not the case. In fact, the variance increases with the average read count.

Generate a plot to show how the standard deviation of genes varies with their mean (across all samples)

```{r}
meanSdPlot(assay(dds), ranks = FALSE)
```

Perform a variance stabilising transformation (VST) on the normalised counts.

VST aims to stabilise variance across the range of mean values. This is important as RNA-seq data typically exhibit a mean-variance relationship, which is where expression level of the gene affects the variability of that gene.

Generate the plot to verify that it has removed the correlation between average read count and variance.

```{r}
# The resultant vsd object contains variance-stabilised normalised counts (this is a log2-like scale but with variance stabilised across the range of counts)
vsd = vst(dds, blind=TRUE) # Do not take into account the experimental design

# Generate plot
meanSdPlot(assay(vsd), ranks = FALSE)
```

Apply log2(n + 1) transformation to the normalised counts using `normTransform()`.

log2(n + 1) transformation helps to make the data more interpretable, especially when dealing with count data that has a wide range of expression levels. n + 1 handles zero values before performing the log transformation.

Generate same plot to verify that it has removed the correlation between average read count and variance.

```{r}
# The resultant ntd object contains log2-transformed normalised counts
ntd = normTransform(dds)

# Generate plot
meanSdPlot(assay(ntd), ranks = FALSE)
```

## PCA

Perform PCA on the variance-stabilised data (`vsd`) and generate a PCA plot using `PlotPCA()`.

PCA is a dimensionality reduction technique that helps to visualise the variation in gene expression data across samples, often revealing patterns such as clustering of samples by condition or batch effects.

The variance-stabilised data is used here as PCA aims to capture the structure in the data by identifying principal components that explain the maximum variance. If variance is not stabilisated, the genes with high variability (which is determined by expression levels) might disproportionately influence the principal components.

```{r}
# intgroup="condition" specifies the grouping variable(s) of interest that will be used to colour the samples in the PCA plot, making it easier to observe how samples group according to this variable
# returnData=TRUE returns the data used to generate the PCA plot instead of the plot itself
pcaData = plotPCA(vsd, intgroup="condition", returnData=TRUE)
```

`pcaData` contains:

-   **PC1**: the coordinates of each sample along the first principal component.

-   **PC2**: the coordinates of each sample along the second principal component.

-   **group**: the grouping variable associated with each sample.

```{r}
knitr::kable(pcaData)
```

List all the attributes associated with `pcaData`. An attribute is a piece of metadata or a property that provides additional information about an object.

```{r}
attributes(pcaData)
```

Calculate the percentage of variance explained by the first two principal components (PC1 and PC2).

This indicates how much of the total variability in the data is captured by these two components.

```{r}
# Retrieve the "percentVar" attribute for the pcaData object, and convert the fraction of variance explained to a percentage
percentVar = round(100 * attr(pcaData, "percentVar"))

percentVar
```

Visualise the PCA plot.

This plot helps to visualise how samples group based on their experimental conditions in the reduced PC space and understand the variance captured by the first two PCs. This can reveal if there are distinct clusters or overlaps between groups.

You can also identify if any samples are outliers.

```{r}
ggplot(pcaData, aes(PC1, PC2, color=condition)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed() + # Ensures that that scaling of the x- and y-axis are fixed
  theme_few()
```

PC1 and PC2 account for 96% of the total variance in the dataset - these two components capture a substantial portion of the data's variability. This indicates that the reduced 2D representation is capturing most of the essential information, making it easier to visualise meaningful patterns/clusters/relationships.

## Quality control

These samples were collected directly after FACs sorting so these cells might be stressed.

Look at highly expressed genes in each condition and see if these genes are enriched in stress-related GO terms.

Select the top 300 genes based on average normalised counts to identify the the genes with the highest expression levels across all the samples.

```{r}
# counts(dds, normalized=TRUE) retrieves the normalised counts
# Calculate the mean normalised count for each gene across all samples
# Order the genes based on their mean normalised counts in descending order (this function returns the indices of the genes)
# Select the top 300 genes with the highest average expression
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:300]

head(select) # Each integer represents the index of a gene in the original dataset
```

Once these genes have been selected, extract the counts data for the top 300 genes from the `ntd` object (which contains the log2 normalised counts).

GO enrichment analysis focuses on expression levels and the log2 transformation helps in compressing the range of expression values and handling zero values. This transformation also mitigates issues like skewness which impacts the assumptions of statistical methods that assume normally distributed data.

```{r}
# Only include the counts of the selected genes
top300 <- as.data.frame(assay(ntd)[select,])

knitr::kable(head(top300))
```

Perform GO enrichment analysis to identify GO terms that are overrepresented among the top 300 genes.

`gost()`, of the [gprofiler2 package](https://cran.r-project.org/web/packages/gprofiler2/gprofiler2.pdf), performs functional enrichment analysis (FEA) on gene lists. FEA is a method to identify classes of genes that are over-represented in a large set of genes. Several data sources are used:

-   **Gene Ontology (GO)**

    -   **GO:MF**: functional roles at the molecular level e.g. "enzyme activity".

    -   **GO:CC**: subcellular localisation where gene product functions e.g. "nucleus".

    -   **GO:BP**: broader biological processes and pathways e.g. "cell division".

<!-- -->

-   **Pathway and Functional databases**

    -   **KEGG**: biological pathways and interactions between different biological molecules.

    -   **REACTOME**: biological pathways and processes.

```{r}
# Perform GO enrichment analysis using the gene identifiers provided in the row name
go_enrich = gost(rownames(top300), organism = "mmusculus",ordered_query = TRUE) # Specify the organism is a mouse and that the gene list is provided in a specific order
# Visualise result of GO enrichment analysis
gostplot(go_enrich, interactive = TRUE)
```

Modify the `go_enrich` data frame to only include relevant columns:

-   `query`: query name/identifier. A query is the set of genes you are interested in investigating.

-   `source`: source of the GO term (e.g. GO, KEGG).

-   `term_id`: ID of the GO term.

-   `term_name`: name/description of the GO term.

-   `p_value`: p-value for the enrichment of the GO term.

-   `query_size`: number of genes in the query list.

-   `intersection_size`: number of genes in the query list that overlap with the GO term.

-   `term_size`: total number of genes associated with the GO term.

-   `effective_domain_size`: the size of the background gene set used for the enrichment analysis. This adjusts for the fact that some GO terms are more likely to be enriched simply because they are associated with a larger number of genes in the genome.

```{r}
gp_mod = go_enrich$result[,c("query", "source", "term_id",
                                "term_name", "p_value", "query_size", 
                                "intersection_size", "term_size", 
                                "effective_domain_size")]

knitr::kable(head(gp_mod))
```

Calculate gene and background ratios to assess the proportion of genes involved in a term relative to the query and background.

-   **GeneRatio**: the ratio of the number of query genes that intersect with the GO term to the total number of genes in the query list. It helps to understand what proportion of the entire query list is associated with a specific GO term.

-   **BgRatio**: the ratio of the number of genes associated with the GO term to the effective domain size. This helps to understand the proportion of background genes associated with the GO term, offering insight into its general relevance.

```{r}
gp_mod$GeneRatio = paste0(gp_mod$intersection_size,  "/", gp_mod$query_size)
gp_mod$BgRatio = paste0(gp_mod$term_size, "/", gp_mod$effective_domain_size)
```

Rename columns.

```{r}
names(gp_mod) = c("Cluster", "Category", "ID", "Description", "p.adjust", 
                    "query_size", "Count", "term_size", "effective_domain_size", 
                    "GeneRatio", "BgRatio")
```

Set the row names of the `gp_mod` data frame to the GO term IDs.

```{r}
row.names(gp_mod) = gp_mod$ID

knitr::kable(head(gp_mod))
```

The `result` data frame, which contains the enrichment analysis, is ordered first by query name, data source (such as GO:BP, GO:CC, etc.), and then by the adjusted p-value.

Filter for the GO:BP data source (to look for biological processes related to stress responses).

```{r}
gp_mod_bp = gp_mod %>%
  filter(Category == "GO:BP")

knitr::kable(head(gp_mod_bp))
```

Create an `enrichResult` object from the modified data frame. This class is used by the `enrichplot` package to generate plots.

```{r}
# Define as enrichResult object
gp_mod_bp_enrich  = new("enrichResult", result = gp_mod_bp)
# Generate a dotplot
# The order of the y-axis is determined by the orderBy= argument
    # Default for orderBy="x" (in this case, "GeneRatio")
dotplot_top300 = enrichplot::dotplot(gp_mod_bp_enrich) +
  ggtitle("Top 300 expressed genes", subtitle = "Gene Ontology:Biological Process") + 
  theme(plot.title = element_text(face="bold"))

dotplot_top300
```

This plot shows the 10 most enriched GO terms (ordered by `GeneRatio`) in genes with the highest expression levels across all the samples.

The GO terms largely relate to normal developmental processes and anatomical structure formation.

Anatomical structure morphogenesis, vasculature development, and blood vessel development are related to normal EC function.

## Explorting the outputs of DEA

```{r}
# Extract the results of the DEA from dds
res = results(dds)

head(res)
```

The default output columns are:

-   **log2FoldChange**: log2 fold change of expression for each gene between conditions.

    -   Fold change values are represented in log2 scale to symmetrically represent both upregulation and downregulation of gene expression. For example, a fold change of 2 (upregulation) and a fold change of -0.5 (downregulation) are symetrically represented as +1 and -1 on a log2 scale.

    -   As raw fold change values can vary widely, using a log2 scale also compresses this range.

-   **lfcSE**: standard error of the log2 fold change.

-   **stat**: test statistics (Wald test or likelihood ratio test) for each gene.

-   **pvalue**: p-value for test of differential expression.

-   **padj**: the adjusted p-value (using the Benjamini-Hochberg procedure) to control for false discovery rate.

List the names of the coefficients (i.e. terms in the design formula) that are available in `dds` for which you can extract results. This is useful for understanding which comparisons are available in the model.

```{r}
resultsNames(dds)
```

### Log-fold shrinkage

Shrinking log2 fold changes is used to reduce noise in low-count genes.

-   Genes with low counts often show exaggerated or highly variable log2 fold changes (i.e. 1 vs 4 counts is a 4x fold change).

-   Shrinking the log2fold changes helps reduce this noise by pulling extreme values towards more conservative or "shrunk" estimates, reflecting more accurate differences in gene expression.

Extract the results of the DEA for lung compared to brain.

```{r}
resLGBR = results(dds, contrast = c("condition", "LG", "BR"))

head(resLGBR)
```

Visualise the relationship between log2 fold changes, significant DE genes, and the gene mean count.

```{r}
plotMA(resLGBR)
```

We can see that genes with low counts tend to have exaggerated fold changes and high levels of variance. However, since these counts are very low, this is probably noise.

Shrinking the log2 fold changes will "shrink" the fold changes of genes with low counts (i.e. genes towards the left of the x-axis).

```{r}
resLGBR_Lfc = lfcShrink(dds, coef = "condition_LG_vs_BR", res = resLGBR)

plotMA(resLGBR_Lfc)
```

### Visualising differentially expressed genes between conditions

#### Heatmap

A heatmap can reveal expression patterns across sample groups (columns) and automatically ordered genes (rows) according to their similarity.

Use the transformed data.

```{r, fig.width=10, fig.height=10}
# Get top 50 differentially expressed genes from res
genes = res[order(res$padj), ] |>
  head(50) |>
  rownames()

# Extract data for heatmap
heatmapdata = assay(vsd)[genes, ]

# Create a gene ID to gene name mapping
id_to_name = setNames(tx2gene$V3, tx2gene$V2)
# Replace gene IDs with gene names
rownames(heatmapdata) = id_to_name[rownames(heatmapdata)]

# Scale transformed counts for visualisation
# Scale each row of the matrix so that each row has a mean of 0 and a standard deviation of 1
# This helps to ensure that the data is centered and scaled for each gene, making it easier to visualise patterns in the heatmap
heatmapdata = t(scale(t(heatmapdata)))

# Extract condition data
heatmapColAnnot = data.frame(colData(vsd)[, "condition"])
# Rename column title
names(heatmapColAnnot) = "Condition"
# Create annotation object for use in the heatmap
heatmapColAnnot = HeatmapAnnotation(df = heatmapColAnnot)

# Plot heatmap
ComplexHeatmap::Heatmap(heatmapdata,
                        top_annotation = heatmapColAnnot,
                        name = "Expression",
                        cluster_rows = TRUE, cluster_columns = FALSE,
                        row_names_gp = grid::gpar(fontsize=10),
                        column_title = "Top 50 DE genes",
                        column_title_gp = gpar(fontsize=15, fontface="bold")) 
```

#### Volcano plot

We want to look for genes that are overexpressed in the brain compared to both lung and liver. Here, this will be represented by genes that have a negative `log2FoldChange` in the comparisons named above.

What kind of threshold should we use for `log2FoldChange` and `padj`? Use a volcano plot to help decide.

```{r}
# Set thresholds
foldchange=2 # Threshold for log2 fold change
pval=0.001 # Threshold for adjusted p-value
```

A volcano plot is a common way to visualise DEA data. It shows the relationship between the magnitude of change (log2 fold change) and statistical significance (adjusted p-value).

-   The adjusted p-value is plotted on the volcano plot as `-log10(padj)`. The raw p-values are often very small for significant results, and visualising them on a log scale compresses a wide range of p-values into a more manageable range where highly significant results are visually distinct.

-   Lower p-values (high significance) are also emphasised as larger values on the y-axis.

```{r}
# Create function that generates a volcano plot that takes a coefficient of dds as an argument
PlotVolcano <-function(comparison){
  # Shrink the log2 fold changes using the apeglm method to stabilise the estimates,       especially for genes with low counts or low variance
  # The output, de, is a DESeq2 object that contains shruken log2 fold changes
  de = lfcShrink(dds, coef=comparison, type="apeglm")
  # Convert de into a data frame, resul
  resul = as.data.frame(de)
  # Extract gene IDs and assign them to resul as a new column
  resul$geneID <- rownames(resul)
  # Merge resul with additional gene annotations (gene names) stored in tx2gene
  # Column "geneID" in res corresponds to column "V2" in tx2gene
  # Keep all rows in resul
  # Only matching rows in tx2gene are kept
  de <- merge(resul, tx2gene, by.x = "geneID", by.y = "V2", all.x = TRUE, all.y = FALSE)
  
  # Filtering and selection
  de = de %>% 
    dplyr::filter(!is.na(log2FoldChange)) %>% # Remove any rows with NA values in the log2FoldChange column
    dplyr::select(-V1) %>% # Remove column "V1" (transcript ID)
    unique() # Remove duplicate rows
  
  # Count how many genes are in each category (unchanged, upregulated, downregulated)
  n_unchanged <- de %>% 
    # Filter for genes where log2FoldChange is between -foldchange and +foldchange
    dplyr::filter(log2FoldChange < foldchange & log2FoldChange > -(foldchange)) %>% 
    # Count how many genes unchanged
    nrow()
  n_up <- de %>%
    # Filter for genes where log2FoldChange is greater than foldchange and significant (based on pval)
    dplyr::filter(log2FoldChange >= foldchange & padj < pval) %>%
    # Count how many genes upregulated
    nrow()
  n_down <- de %>% 
    # Filter for genes where log2FoldChange is less than -foldchange and significant (based on pval)
    dplyr::filter(log2FoldChange <= -(foldchange) & padj < pval) %>% 
    # Count how many genes downregulated
    nrow()
  
  # Assign DE labels to genes
  # Create "Expression" column and label all genes as "Unchanged" with total count of unchanged genes
  de$Expression <- paste0("Unchanged (",n_unchanged,")")
  # For genes where log2FoldChange is greater than foldchange and significant, the label is updated to "Up" with a total count of upregulated genes
  de$Expression[de$log2FoldChange >= foldchange & de$padj < pval] <- paste0("Up (",n_up,")")
  # For genes where log2FoldChange is less than -foldchange and significant, the label is updated to "Down" with a total count of downregulated genes
  de$Expression[de$log2FoldChange <= -(foldchange) & de$padj < pval] <- paste0("Down (",n_down,")")
  
  # Set colours for plot - the order of colours will correspond to the order of levels in the factor variable de$Expression
  if (n_up == 0 & n_down == 0){ # If there are no up or downregulated genes
      cvec = c("#84A1AB") # Use grey-blue for all genes
  } else if (n_up == 0){ # If there are only downregulated genes
      cvec = c("#B02302", "#84A1AB") # Use red for down genes and grey-blue for unchanged genes
  } else if (n_down == 0){ # If there are only upregulated genes
      cvec = c("#84A1AB", "#61B002") # Use grey-blue for unchanged genes and green for up genes
  } else { # If there are downregulated and upregulated genes
      cvec = c("#B02302", "#84A1AB", "#61B002") # Use red for down genes, and grey-blue for unchanged genes, and green for up genes
  }
  
  # Add gene names to genes that are differentially expressed
  # Create "delabel" column and initialise with NA values for all rows (by default, no genes are labelled on the plot)
  de$delabel <- NA
  # Select "delabel" entries where "Expression" does not contain "Unchanged"
  # Select and assign gene names (from "V3") where "Expression" does not contain "Unchanged"
  de$delabel[!grepl("Unchanged", de$Expression)] <- de$V3[!grepl("Unchanged", de$Expression)]
  # Sort the data frame by adjusted p-values
  de=de[order(de$padj),]
  
  
  # Generate the volcano plot
  # The x-axis is mapped to the log2 fold change values (i.e. magnitude of change)
  # The y-axis is mapped to the -log10  of the padj values (i.e. significance)
  ggplot(data=de, aes(x=log2FoldChange, y=-log10(padj))) +
          # Add vertical dashed lines at the foldchange thresholds
          geom_vline(xintercept=c(-(foldchange), foldchange), col="light grey", linetype="dashed") +
          # Add horizontal dashed line at the pval threshold
          geom_hline(yintercept=-log10(pval), col="light grey", linetype="dashed") +
          # Add points to the plot, coloured by "Expression" column
          geom_point(aes(color=Expression), alpha=0.5) +
          # Add text lables (avoiding overlap) to the top 50 most signficant DE genes
          # Set x- and y-coordinates for labels using "log2FoldChange" and "padj" columns
          geom_text_repel(data=de[1:50,],aes(x = log2FoldChange, y = -log10(padj),label=delabel),max.overlaps=50,size=3) +
          # Use colours specified earlier
          scale_color_manual(values=cvec) +
          # Set appearance
          theme_few() +theme(aspect.ratio=1) +
          labs(title = comparison)
}
```

```{r}
PlotVolcano("condition_LG_vs_BR")
```

```{r}
PlotVolcano("condition_LV_vs_BR")
```

#### GO enrichment analysis

Look at genes overexpressed in the brain compared to both lung and liver.

Identify genes that are significantly downregulated (negative fold change) in lung samples compared to brain samples.

```{r, message=FALSE}
# Shrink the log2 fold changes using the apeglm method to stabilise the estimates,       especially for genes with low counts
brainlung = lfcShrink(dds, coef="condition_LG_vs_BR", type="apeglm") %>%
  # Covert the DESeq2 object to a data frame
  as.data.frame() %>%
  # Filter genes for signficance and log2 fold change
  filter(padj<0.001 & log2FoldChange <= -2) %>%
  # Extract row names of filtered data frame
  rownames()

head(brainlung) # The output is a vector of gene IDs
```

Identify genes that are significantly downregulated (negative fold change) in liver samples compared to brain samples.

```{r, message=FALSE}
# Shrink the log2 fold changes using the apeglm method to stabilise the estimates,       especially for genes with low counts
brainliver = lfcShrink(dds, coef="condition_LV_vs_BR", type="apeglm") %>%
  # Covert the DESeq2 object to a data frame
  as.data.frame() %>%
  # Filter genes for signficance and log2 fold change
  filter(padj<0.001 & log2FoldChange <= -2) %>%
  # Extract row names of filtered data frame
  rownames()

head(brainliver) # The output is a vector of gene IDs
```

```{r}
length(brainlung) # 366 genes are downregulated in LG compared to BR
```

```{r}
length(brainliver) # 686 genes are downregulated in LV compared to BR
```

Get the genes that are downregulated in both the lung and liver compared to the brain.

```{r}
# interest() returns the gene IDs that are common to both vectors
brain_enriched = intersect(brainlung,brainliver) %>% 
# Remove duplicates
  unique()

length(brain_enriched) # 209 genes are downregulated in LG and LV compared to the brain
```

Perform GO analysis to see what kind of gene networks they belong to.

```{r}
# Perform GO enrichment analysis using the brain enriched genes
go_enrich = gost(brain_enriched, organism = "mmusculus")  # Specify the organism is a mouse
# Visualise result of GO enrichment analysis
gostplot(go_enrich, interactive = TRUE)
```

Modify the `go_enrich` data frame as done earlier.

```{r}
# Only include relevant columns
gp_mod = go_enrich$result[,c("query", "source", "term_id",
                                "term_name", "p_value", "query_size", 
                                "intersection_size", "term_size", 
                                "effective_domain_size")]

# Calculate GeneRatio and BgRatio
gp_mod$GeneRatio = paste0(gp_mod$intersection_size,  "/", gp_mod$query_size)
gp_mod$BgRatio = paste0(gp_mod$term_size, "/", gp_mod$effective_domain_size)

# Rename columns
names(gp_mod) = c("Cluster", "Category", "ID", "Description", "p.adjust", 
                    "query_size", "Count", "term_size", "effective_domain_size", 
                    "GeneRatio", "BgRatio")

# Set row names to the GO term IDs
row.names(gp_mod) = gp_mod$ID

# Filter
gp_mod_bp = gp_mod %>%
  filter(Category == "GO:BP")

# Define as enrichResult object
gp_mod_bp_enrich  = new("enrichResult", result = gp_mod_bp)

knitr::kable(head(gp_mod_bp))
```

Generate a bar plot to visualise the result of the GO enrichment analysis, showing the top 10 enriched GO terms.

```{r, fig.width=10, fig.height=6}
barplot_BR_OE = barplot(gp_mod_bp_enrich, showCategory = 10, font.size = 12) + 
  ggplot2::facet_grid(~Cluster) +
  ggtitle("Brain-enriched genes", subtitle = "Gene Ontology:Biological Process")  + 
  theme(plot.title = element_text(face="bold"))

barplot_BR_OE
```

This plot shows the 10 most enriched GO terms (ordered by `p.adjust`) in genes overexpressed in the brain compared to lung and liver.
